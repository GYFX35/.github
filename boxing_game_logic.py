import enum
import time # For game tick simulation later
import random # For AI and hit chances

# --- Constants ---
MAX_HP = 100
MAX_STAMINA = 100
ROUND_DURATION_SECONDS = 90
MAX_ROUNDS = 3
STAMINA_REGEN_PER_SECOND = 5
STAMINA_REGEN_BETWEEN_ROUNDS = 25
KNOCKDOWN_COUNT_MAX = 10

# --- Enums ---
class ActionType(enum.Enum):
    JAB = "JAB"
    CROSS = "CROSS"
    HOOK = "HOOK"
    UPPERCUT = "UPPERCUT"
    BLOCK = "BLOCK"
    DODGE = "DODGE"
    ADVANCE = "ADVANCE"
    RETREAT = "RETREAT"
    SIDESTEP_LEFT = "SIDESTEP_LEFT"
    SIDESTEP_RIGHT = "SIDESTEP_RIGHT"
    IDLE = "IDLE" # When no specific action is being taken

class GameStatus(enum.Enum):
    PENDING = "pending"
    ACTIVE = "active"
    PAUSED = "paused"
    ROUND_OVER = "round_over"
    BETWEEN_ROUNDS = "between_rounds"
    MATCH_OVER = "match_over"

class FighterName(enum.Enum):
    PLAYER = "Player"
    OPPONENT = "Opponent"

# --- Action Details (similar to JavaScript ACTION_DETAILS) ---
# Using a dictionary for now, could be attributes of ActionType enum members if preferred
ACTION_DETAILS = {
    ActionType.JAB: {"damage": 5, "stamina_cost": 5, "speed": 8, "accuracy": 0.85},
    ActionType.CROSS: {"damage": 10, "stamina_cost": 10, "speed": 6, "accuracy": 0.75},
    ActionType.HOOK: {"damage": 12, "stamina_cost": 15, "speed": 5, "accuracy": 0.70},
    ActionType.UPPERCUT: {"damage": 15, "stamina_cost": 20, "speed": 4, "accuracy": 0.65},
    ActionType.BLOCK: {"stamina_cost_on_hit": 3, "stamina_cost_active_drain": 0.5}, # Example: cost when hit, and small drain if held
    ActionType.DODGE: {"stamina_cost": 10},
    ActionType.IDLE: {"damage": 0, "stamina_cost": 0, "speed": 0, "accuracy": 0.0}
    # Movement actions don't have damage/accuracy in the same way, handle separately
}

if __name__ == '__main__':
    # Example usage of Enums and Constants
    print(f"Max HP: {MAX_HP}")
    print(f"Jab Action: {ActionType.JAB}, Damage: {ACTION_DETAILS[ActionType.JAB]['damage']}")
    print(f"Game Initial Status: {GameStatus.PENDING.value}")

# Next steps will be to define Fighter and GameState classes.
# This file will be expanded as we go through the plan.

# --- Helper function for fighter stats ---
def create_empty_fighter_stats():
    return {
        "punches_thrown": 0,
        "punches_landed": 0,
        "damage_dealt": 0,
        ActionType.JAB: {"thrown": 0, "landed": 0},
        ActionType.CROSS: {"thrown": 0, "landed": 0},
        ActionType.HOOK: {"thrown": 0, "landed": 0},
        ActionType.UPPERCUT: {"thrown": 0, "landed": 0},
        "knockdowns_scored": 0
    }

# --- Classes ---
class Fighter:
    def __init__(self, name: FighterName):
        self.name = name
        self.hp = MAX_HP
        self.max_hp = MAX_HP
        self.stamina = MAX_STAMINA
        self.max_stamina = MAX_STAMINA
        self.knockdowns_this_round = 0
        self.total_knockdowns = 0
        self.current_action = ActionType.IDLE
        self.action_start_time = 0 # To time actions like blocking
        self.stats = create_empty_fighter_stats()
        self.round_scores = [] # List to store points awarded per round
        # self.position = {"x": 0, "y": 0, "z": 0} # Basic position if needed later

    def __str__(self):
        return f"{self.name.value} (HP: {self.hp}/{self.max_hp}, SP: {self.stamina}/{self.max_stamina})"

    def can_perform_action(self, action_type: ActionType) -> bool:
        if action_type not in ACTION_DETAILS:
            return True # For non-stamina costing actions like IDLE or movement (cost handled elsewhere if any)
        action_cost = ACTION_DETAILS[action_type].get("stamina_cost", 0)
        return self.stamina >= action_cost and self.hp > 0

    def apply_damage(self, damage: int):
        self.hp = max(0, self.hp - damage)

    def consume_stamina(self, cost: int):
        self.stamina = max(0, self.stamina - cost)

    def regenerate_stamina(self, amount: int):
        if self.hp > 0: # Cannot regenerate if knocked out
            self.stamina = min(self.max_stamina, self.stamina + amount)

    def reset_for_new_round(self):
        self.knockdowns_this_round = 0
        # Stamina is regenerated by the game state logic between rounds typically

    def record_action_stat(self, action_type: ActionType, landed: bool, damage_dealt: int = 0):
        self.stats["punches_thrown"] += 1
        if action_type in [ActionType.JAB, ActionType.CROSS, ActionType.HOOK, ActionType.UPPERCUT]:
            self.stats[action_type]["thrown"] += 1
            if landed:
                self.stats["punches_landed"] += 1
                self.stats[action_type]["landed"] += 1
                self.stats["damage_dealt"] += damage_dealt


class GameState:
    def __init__(self):
        self.match_status = GameStatus.PENDING
        self.current_round = 0
        self.max_rounds = MAX_ROUNDS
        self.round_timer = ROUND_DURATION_SECONDS # Seconds remaining in current round
        self.is_round_active = False
        self.between_rounds_timer = 0
        self.winner = None  # FighterName or "draw"

        self.player = Fighter(FighterName.PLAYER)
        self.opponent = Fighter(FighterName.OPPONENT) # Basic AI for now

        self.knockdown_info = {
            "is_knockdown": False,
            "fighter_down": None, # FighterName
            "count": 0
        }
        self.event_log = []
        self.last_tick_time = 0

    def __str__(self):
        return (f"Round: {self.current_round}/{self.max_rounds}, Timer: {self.round_timer:.1f}s, "
                f"Status: {self.match_status.value}\n"
                f"Player: {self.player}\nOpponent: {self.opponent}")

    def log_event(self, message: str):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"[{timestamp}] {message}"
        print(log_entry) # For real-time feedback during development
        self.event_log.append(log_entry)
        if len(self.event_log) > 100: # Keep log from growing too large
            self.event_log.pop(0)

    def get_fighter_by_name(self, name: FighterName) -> Fighter:
        if name == FighterName.PLAYER:
            return self.player
        return self.opponent

if __name__ == '__main__':
    # Example usage of Enums and Constants
    print(f"Max HP: {MAX_HP}")
    print(f"Jab Action: {ActionType.JAB}, Damage: {ACTION_DETAILS[ActionType.JAB]['damage']}")
    print(f"Game Initial Status: {GameStatus.PENDING.value}")

    # Test class instantiation
    player = Fighter(FighterName.PLAYER)
    opponent = Fighter(FighterName.OPPONENT)
    game = GameState()
    print(player)
    print(opponent)
    print(game)
    game.log_event("Game initialized.")
    print(f"Player can Jab: {player.can_perform_action(ActionType.JAB)}")
    player.consume_stamina(ACTION_DETAILS[ActionType.JAB]['stamina_cost'])
    print(f"Player stamina after Jab: {player.stamina}")
    player.apply_damage(30)
    print(f"Player HP after taking damage: {player.hp}")

# --- Core Game Mechanics ---

def initialize_new_game() -> GameState:
    """Creates and returns a fresh GameState instance."""
    game = GameState()
    game.log_event("New game initialized.")
    # Potential further setup: e.g., set opponent AI profile if we have different types
    return game

def execute_fighter_action(game_state: GameState, attacker_name: FighterName, action_type: ActionType):
    """
    Handles the execution of an action by a fighter (player or opponent).
    Updates game state based on the action (damage, stamina, stats, knockdowns).
    """
    attacker = game_state.get_fighter_by_name(attacker_name)
    defender_name = FighterName.OPPONENT if attacker_name == FighterName.PLAYER else FighterName.PLAYER
    defender = game_state.get_fighter_by_name(defender_name)

    if not attacker.can_perform_action(action_type):
        game_state.log_event(f"{attacker.name.value} tried {action_type.value} but couldn't (low stamina/HP).")
        attacker.current_action = ActionType.IDLE # Ensure action is reset
        return

    action_info = ACTION_DETAILS.get(action_type)
    if not action_info: # Movement or other non-combat actions
        attacker.current_action = action_type
        game_state.log_event(f"{attacker.name.value} performs {action_type.value}.")
        # Movement logic would be handled separately if it has specific effects on distance, etc.
        # For now, just log and set current_action. Stamina cost for movement can be added.
        return

    attacker.consume_stamina(action_info["stamina_cost"])
    attacker.current_action = action_type
    attacker.action_start_time = time.time() # For timed actions like block

    game_state.log_event(f"{attacker.name.value} uses {action_type.value} (Stamina: {attacker.stamina})")
    attacker.record_action_stat(action_type, landed=False) # Initially record as thrown

    is_blocked = defender.current_action == ActionType.BLOCK
    # Basic hit chance calculation
    hit_roll = random.random()
    accuracy = action_info.get("accuracy", 0) # Default to 0 if no accuracy defined (e.g. for block)

    if action_type in [ActionType.JAB, ActionType.CROSS, ActionType.HOOK, ActionType.UPPERCUT]:
        if is_blocked:
            game_state.log_event(f"{defender.name.value} blocks the {action_type.value}!")
            defender.consume_stamina(ACTION_DETAILS[ActionType.BLOCK]["stamina_cost_on_hit"])
            # Potentially reduced "chip" damage even on block, or guard break mechanic later
            # For now, block negates damage fully.
            attacker.record_action_stat(action_type, landed=False) # Update: it was blocked, not landed on target HP
        elif hit_roll < accuracy:
            damage = action_info["damage"]
            defender.apply_damage(damage)
            attacker.record_action_stat(action_type, landed=True, damage_dealt=damage) # Update: landed
            game_state.log_event(
                f"{action_type.value} from {attacker.name.value} lands! "
                f"{defender.name.value} HP: {defender.hp}"
            )
            if defender.hp <= 0:
                handle_knockdown(game_state, defender_name, attacker_name)
        else:
            game_state.log_event(f"{action_type.value} from {attacker.name.value} missed.")
            attacker.record_action_stat(action_type, landed=False) # Update: missed

    elif action_type == ActionType.BLOCK:
        # Block is a state. Its effect happens when an opponent attacks.
        # Stamina drain while active blocking can be handled in game_tick.
        pass
    elif action_type == ActionType.DODGE:
        # Dodge effect: if opponent attacks during dodge window, it's a miss.
        # Could also set up a counter-attack window.
        pass

    # Reset attacker's action to IDLE after a short duration for non-continuous actions
    # Continuous actions like BLOCK will be managed by their own logic or by game_tick
    if action_type not in [ActionType.BLOCK]: # Block might persist
         # This is a simplification; in a real-time game, actions have durations.
         # For now, assume offensive actions are somewhat instant for turn-based processing.
        attacker.current_action = ActionType.IDLE


def handle_knockdown(game_state: GameState, downed_fighter_name: FighterName, attacker_name: FighterName):
    """Manages the knockdown sequence."""
    if game_state.knockdown_info["is_knockdown"]: # Another knockdown already in progress
        return

    downed_fighter = game_state.get_fighter_by_name(downed_fighter_name)
    attacker = game_state.get_fighter_by_name(attacker_name)

    downed_fighter.knockdowns_this_round += 1
    downed_fighter.total_knockdowns += 1
    attacker.stats["knockdowns_scored"] += 1

    game_state.knockdown_info["is_knockdown"] = True
    game_state.knockdown_info["fighter_down"] = downed_fighter_name
    game_state.knockdown_info["count"] = 0
    game_state.is_round_active = False # Pause round during knockdown count

    game_state.log_event(f"{downed_fighter.name.value} is KNOCKED DOWN by {attacker.name.value}!")

    # TKO Check: 3 knockdowns in a round
    if downed_fighter.knockdowns_this_round >= 3:
        game_state.log_event(f"Three knockdowns in this round! {attacker.name.value} wins by TKO!")
        game_state.winner = attacker.name
        # game_state.match_status = GameStatus.MATCH_OVER # This will be set by end_match
        # end_match(game_state) # This might be called from game_tick or a managing function
        return # Match ends here due to TKO

    # The actual 10-count will be managed by game_tick or a similar time-based update function.
    # For now, this function sets up the state for that.

if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing Core Mechanics ---")
    game = initialize_new_game()
    print(game)

    # Player Jabs Opponent
    execute_fighter_action(game, FighterName.PLAYER, ActionType.JAB)
    print(game)
    # Opponent Jabs Player
    execute_fighter_action(game, FighterName.OPPONENT, ActionType.JAB)
    print(game)

    # Player blocks, Opponent Jabs
    game.player.current_action = ActionType.BLOCK # Manually set player to block for test
    game.player.action_start_time = time.time()
    game.log_event(f"{game.player.name.value} is now blocking.")
    execute_fighter_action(game, FighterName.OPPONENT, ActionType.JAB)
    print(game)
    game.player.current_action = ActionType.IDLE # Reset block

    # Simulate player knocking down opponent
    game.opponent.hp = ACTION_DETAILS[ActionType.CROSS]["damage"] # Set HP to be knocked out by one cross
    game.log_event(f"Setting opponent HP to {game.opponent.hp} for knockdown test.")
    execute_fighter_action(game, FighterName.PLAYER, ActionType.CROSS)
    print(game)
    print(f"Knockdown info: {game.knockdown_info}")
    if game.winner:
        print(f"Winner after knockdown test: {game.winner.value}")

# --- Round and Match Progression ---

def start_new_round(game_state: GameState):
    """Initializes settings for the start of a new round."""
    game_state.current_round += 1
    game_state.is_round_active = True
    game_state.match_status = GameStatus.ACTIVE
    game_state.round_timer = ROUND_DURATION_SECONDS

    game_state.player.reset_for_new_round()
    game_state.opponent.reset_for_new_round()

    # Regenerate some stamina between rounds
    game_state.player.regenerate_stamina(STAMINA_REGEN_BETWEEN_ROUNDS)
    game_state.opponent.regenerate_stamina(STAMINA_REGEN_BETWEEN_ROUNDS)

    game_state.knockdown_info["is_knockdown"] = False # Ensure no carry-over knockdown state
    game_state.knockdown_info["fighter_down"] = None
    game_state.knockdown_info["count"] = 0

    game_state.log_event(
        f"Round {game_state.current_round} starting! Player SP: {game_state.player.stamina}, Opponent SP: {game_state.opponent.stamina}"
    )
    game_state.last_tick_time = time.time() # Reset tick timer for the new round

def end_round_due_to_time(game_state: GameState):
    """Handles the end of a round when the timer expires."""
    game_state.is_round_active = False
    game_state.log_event(f"Round {game_state.current_round} has ended due to time.")

    score_round(game_state) # Assign points for the completed round

    if game_state.current_round >= game_state.max_rounds:
        game_state.log_event("Maximum rounds reached.")
        end_match(game_state)
    else:
        game_state.match_status = GameStatus.BETWEEN_ROUNDS
        game_state.log_event("Proceeding to next round shortly.")
        # A delay or specific trigger would start the next round in a full game loop

def end_match(game_state: GameState):
    """Finalizes the match, determining a winner if not already set by KO/TKO."""
    game_state.is_round_active = False # Ensure no further actions
    game_state.match_status = GameStatus.MATCH_OVER

    if game_state.winner: # Winner already determined by KO/TKO
        game_state.log_event(f"Match ended. Winner by KO/TKO: {game_state.winner.value}")
    else: # Match ended by rounds completing, determine by decision
        determine_winner_by_decision(game_state)
        if game_state.winner:
            game_state.log_event(f"Match ended. Winner by decision: {game_state.winner if isinstance(game_state.winner, str) else game_state.winner.value}")
        else: # Should mean it's a draw
             game_state.log_event(f"Match ended in a DRAW.")


    # Further actions: display final stats, offer rematch, etc.

def score_round(game_state: GameState):
    """
    Scores the completed round based on performance (simplified for now).
    Uses a 10-point must system.
    """
    player_score = 0
    opponent_score = 0

    # Simplified criteria: damage dealt. More complex: punches landed, aggression, defense.
    # For this example, let's assume we need to sum damage dealt *in this specific round*.
    # The current stats are cumulative, so this needs refinement if we want per-round exactness for scoring.
    # For now, we'll use total damage as a proxy.

    # This is a placeholder. Proper round scoring would require tracking stats per round.
    # Let's use a proxy: whoever has more HP at the end of the round, or dealt more relative damage.
    # Or, more simply, award based on knockdowns primarily.

    if game_state.player.stats["damage_dealt"] > game_state.opponent.stats["damage_dealt"]: # Placeholder for actual round performance
        player_score = 10
        opponent_score = 9
    elif game_state.opponent.stats["damage_dealt"] > game_state.player.stats["damage_dealt"]:
        opponent_score = 10
        player_score = 9
    else: # Equal performance or no clear winner based on this simple metric
        player_score = 10 # Could be 9-9 for some judging styles for an even round
        opponent_score = 10

    # Adjust for knockdowns in the round
    # Player knocked down opponent
    player_knockdowns_on_opponent = game_state.opponent.knockdowns_this_round
    # opponent_knockdowns_on_player = game_state.player.knockdowns_this_round

    # This logic is a bit confusing. Let's simplify:
    # If player scored knockdowns, opponent score is reduced.
    # If opponent scored knockdowns, player score is reduced.

    # Score for player: 10 (base if won round) or 9 (base if lost round)
    # Score for opponent: 10 (base if won round) or 9 (base if lost round)

    # Example: if player won the round (10-9), but was knocked down once, it becomes 9-9.
    # If player won round (10-9) and knocked opponent down once, it becomes 10-8 for player.

    # Let's use a simpler direct assignment based on who did better, then adjust.
    # Assume player_score and opponent_score are initially 0.
    # The "10-point must" system: winner of round gets 10, loser gets 9.
    # Exception: if loser is knocked down, they get 8. If knocked down twice, 7.

    # Simplified scoring:
    # 1. Determine round winner (e.g. based on damage, aggression - very basic for now)
    p_round_damage = game_state.player.stats["damage_dealt"] # This is total, not per-round, needs fixing for real scoring
    o_round_damage = game_state.opponent.stats["damage_dealt"]

    round_winner = None
    if p_round_damage > o_round_damage : round_winner = game_state.player
    elif o_round_damage > p_round_damage : round_winner = game_state.opponent

    if round_winner == game_state.player:
        player_score = 10
        opponent_score = 9 - game_state.opponent.knockdowns_this_round # if opponent was knocked down
        if game_state.opponent.knockdowns_this_round > 0 : opponent_score = max(7, 9 - game_state.opponent.knockdowns_this_round) # Min score usually 7
        else: opponent_score = 9
        if game_state.player.knockdowns_this_round > 0: # If player won round but was also knocked down
            player_score = max(7, 10 - game_state.player.knockdowns_this_round)

    elif round_winner == game_state.opponent:
        opponent_score = 10
        player_score = 9 - game_state.player.knockdowns_this_round # if player was knocked down
        if game_state.player.knockdowns_this_round > 0: player_score = max(7, 9 - game_state.player.knockdowns_this_round)
        else: player_score = 9
        if game_state.opponent.knockdowns_this_round > 0: # If opponent won round but was also knocked down
            opponent_score = max(7, 10 - game_state.opponent.knockdowns_this_round)
    else: # Even round
        player_score = 10 - game_state.player.knockdowns_this_round
        opponent_score = 10 - game_state.opponent.knockdowns_this_round
        player_score = max(7, player_score)
        opponent_score = max(7, opponent_score)


    game_state.player.round_scores.append(player_score)
    game_state.opponent.round_scores.append(opponent_score)
    game_state.log_event(
        f"Round {game_state.current_round} scored: Player {player_score}, Opponent {opponent_score}"
    )
    # Crucially, for accurate round-by-round scoring, stats like damage_dealt
    # would need to be reset or snapshotted at the start/end of each round.
    # The current Fighter.stats are cumulative for the whole match.

def determine_winner_by_decision(game_state: GameState):
    """Determines the winner based on accumulated round scores."""
    total_player_score = sum(game_state.player.round_scores)
    total_opponent_score = sum(game_state.opponent.round_scores)

    game_state.log_event(
        f"Decision: Player Total Score {total_player_score}, Opponent Total Score {total_opponent_score}"
    )

    if total_player_score > total_opponent_score:
        game_state.winner = game_state.player.name # Store FighterName enum
    elif total_opponent_score > total_player_score:
        game_state.winner = game_state.opponent.name # Store FighterName enum
    else:
        game_state.winner = "draw" # Special string for draw


if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing Round/Match Progression ---")
    game = initialize_new_game()

    # Simulate a few rounds
    for r in range(1, game.max_rounds + 1):
        start_new_round(game)
        print(game)
        # Simulate some actions in the round
        execute_fighter_action(game, FighterName.PLAYER, ActionType.JAB)
        execute_fighter_action(game, FighterName.OPPONENT, ActionType.JAB)
        if r == 1: # Player scores a knockdown in round 1
            game.opponent.hp = 1
            execute_fighter_action(game, FighterName.PLAYER, ActionType.JAB) # Knockdown
            # Manually advance knockdown count for testing since game_tick isn't running
            if game.knockdown_info["is_knockdown"]:
                 game.knockdown_info["count"] = KNOCKDOWN_COUNT_MAX -1 # Almost KO'd but gets up
                 game_state.log_event(f"{game.knockdown_info['fighter_down'].value} gets up at count {game.knockdown_info['count']}")
                 game.knockdown_info["is_knockdown"] = False
                 game.is_round_active = True # Resume round
                 game.opponent.hp = 20 # Recover some HP

        game.round_timer = 0 # End round by time
        end_round_due_to_time(game)
        if game.match_status == GameStatus.MATCH_OVER:
            break

    if game.match_status != GameStatus.MATCH_OVER: # Should be MATCH_OVER if all rounds played
        end_match(game) # Ensure match ends if loop finishes

    print(f"Final Player Scores: {game.player.round_scores}")
    print(f"Final Opponent Scores: {game.opponent.round_scores}")
    print(f"Match Winner: {game.winner if isinstance(game.winner, str) else game.winner.value if game.winner else 'N/A'}")


# --- Basic AI Logic ---

def decide_ai_action(game_state: GameState) -> ActionType:
    """
    Simple AI decision-making logic for the opponent.
    Returns an ActionType for the opponent to perform.
    """
    opponent = game_state.opponent
    player = game_state.player

    # Very basic AI:
    # 1. If low stamina, try to rest (IDLE) or throw a quick jab if possible.
    # 2. If player is low HP, be more aggressive.
    # 3. If player is blocking, maybe wait or try a feint (not implemented yet).
    # 4. Otherwise, mix of attack and defense.

    possible_actions = []

    if not opponent.can_perform_action(ActionType.JAB) and \
       not opponent.can_perform_action(ActionType.CROSS) and \
       not opponent.can_perform_action(ActionType.BLOCK): # Cannot do much
        return ActionType.IDLE # Conserve stamina or is stunned/unable

    # Stamina considerations
    if opponent.stamina < ACTION_DETAILS[ActionType.CROSS]["stamina_cost"]: # Not enough for a cross
        if opponent.can_perform_action(ActionType.JAB):
            possible_actions.append(ActionType.JAB)
        if opponent.can_perform_action(ActionType.BLOCK):
             possible_actions.append(ActionType.BLOCK)
        if not possible_actions: return ActionType.IDLE
        return random.choice(possible_actions)

    # Aggression if player is low HP
    if player.hp < MAX_HP * 0.3: # Player is weak
        if opponent.can_perform_action(ActionType.CROSS):
            possible_actions.append(ActionType.CROSS)
        if opponent.can_perform_action(ActionType.JAB):
            possible_actions.append(ActionType.JAB)

    # Default actions
    if opponent.can_perform_action(ActionType.JAB): possible_actions.append(ActionType.JAB)
    if opponent.can_perform_action(ActionType.CROSS): possible_actions.append(ActionType.CROSS)
    if opponent.can_perform_action(ActionType.HOOK): possible_actions.append(ActionType.HOOK) # Add hook if enough stamina
    if opponent.can_perform_action(ActionType.UPPERCUT): possible_actions.append(ActionType.UPPERCUT) # Add uppercut

    if opponent.can_perform_action(ActionType.BLOCK):
        # Add block more frequently if player is aggressive or AI is defensive
        if player.current_action not in [ActionType.IDLE, ActionType.BLOCK] or opponent.hp < MAX_HP * 0.5:
            possible_actions.extend([ActionType.BLOCK] * 3) # Weight block higher
        else:
            possible_actions.append(ActionType.BLOCK)

    # Basic distance consideration (conceptual, as distance isn't fully implemented)
    # if distance_between_fighters > certain_threshold:
    #     if opponent.can_perform_action(ActionType.ADVANCE): possible_actions.append(ActionType.ADVANCE)
    # else: # Close range
    #     if opponent.can_perform_action(ActionType.UPPERCUT): possible_actions.append(ActionType.UPPERCUT)

    if not possible_actions:
        return ActionType.IDLE # Fallback if no other action is viable

    return random.choice(possible_actions)


if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing AI Decision ---")
    game = initialize_new_game()
    start_new_round(game) # Need a round to be active for AI to consider actions properly

    for _ in range(10): # Simulate a few AI decisions
        ai_action = decide_ai_action(game)
        print(f"AI decided to: {ai_action.value}")
        if ai_action != ActionType.IDLE and ai_action != ActionType.BLOCK : # Simulate performing the action to change state
             if game.opponent.can_perform_action(ai_action):
                game.opponent.consume_stamina(ACTION_DETAILS[ai_action]["stamina_cost"])
        elif ai_action == ActionType.BLOCK:
            game.opponent.current_action = ActionType.BLOCK
            # AI might hold block for a bit in a real game tick
        # Simulate player action to change context for AI
        if random.random() < 0.5 and game.player.can_perform_action(ActionType.JAB):
            execute_fighter_action(game, FighterName.PLAYER, ActionType.JAB)
            print(f"Player threw a JAB. Player HP: {game.player.hp}, Opponent HP: {game.opponent.hp}")

        print(f"Opponent state: HP {game.opponent.hp}, Stamina {game.opponent.stamina}")


# --- Basic Game Loop Structure (for testing logic) ---

PLAYER_ACTION_QUEUE = [] # Global queue for player actions, for testing game_tick

def queue_player_action_for_tick(action: ActionType):
    """Adds a player action to the queue for game_tick to process."""
    PLAYER_ACTION_QUEUE.append(action)

def game_tick(game_state: GameState):
    """
    Simulates one tick or step of the game.
    Processes player inputs, AI actions, updates timers, checks conditions.
    This is a simplified version for testing the logic before API/WebSockets.
    """
    if game_state.match_status == GameStatus.MATCH_OVER:
        return # Game has ended

    current_time = time.time()
    delta_time = current_time - game_state.last_tick_time
    game_state.last_tick_time = current_time

    # Handle knockdown count
    if game_state.knockdown_info["is_knockdown"]:
        game_state.knockdown_info["count"] += delta_time # Increment count by time passed
        game_state.log_event(f"Knockdown count: {game_state.knockdown_info['count']:.1f}")
        if game_state.knockdown_info["count"] >= KNOCKDOWN_COUNT_MAX:
            downed_fighter_name = game_state.knockdown_info["fighter_down"]
            attacker_name = FighterName.PLAYER if downed_fighter_name == FighterName.OPPONENT else FighterName.OPPONENT

            game_state.log_event(f"{downed_fighter_name.value} is KNOCKED OUT!")
            game_state.winner = attacker_name
            end_match(game_state)
            return # Match ends
        # No "getting up" mechanic yet if HP is 0. If HP > 0, could add it here.
        return # Pause other game logic during knockdown count

    if not game_state.is_round_active:
        if game_state.match_status == GameStatus.BETWEEN_ROUNDS:
            # Could have a timer for between_rounds state
            game_state.between_rounds_timer -= delta_time
            if game_state.between_rounds_timer <=0:
                start_new_round(game_state)
        return # Round not active (e.g., between rounds, paused)

    # Update round timer
    game_state.round_timer -= delta_time

    # Regenerate stamina for both fighters based on delta_time
    # STAMINA_REGEN_PER_SECOND is 'units per second', so multiply by delta_time
    game_state.player.regenerate_stamina(STAMINA_REGEN_PER_SECOND * delta_time)
    game_state.opponent.regenerate_stamina(STAMINA_REGEN_PER_SECOND * delta_time)

    # Active block stamina drain
    if game_state.player.current_action == ActionType.BLOCK:
        cost = ACTION_DETAILS[ActionType.BLOCK]["stamina_cost_active_drain"] * delta_time
        game_state.player.consume_stamina(cost)
        if not game_state.player.can_perform_action(ActionType.BLOCK): # No more stamina for block
            game_state.player.current_action = ActionType.IDLE
            game_state.log_event("Player block broke due to low stamina.")
    if game_state.opponent.current_action == ActionType.BLOCK:
        cost = ACTION_DETAILS[ActionType.BLOCK]["stamina_cost_active_drain"] * delta_time
        game_state.opponent.consume_stamina(cost)
        if not game_state.opponent.can_perform_action(ActionType.BLOCK):
            game_state.opponent.current_action = ActionType.IDLE
            game_state.log_event("Opponent block broke due to low stamina.")


    # Process Player action from queue (if any)
    if PLAYER_ACTION_QUEUE:
        player_action = PLAYER_ACTION_QUEUE.pop(0)
        # Check if player is stunned or otherwise unable to act (future enhancement)
        if game_state.player.current_action == ActionType.IDLE: # Can only act if idle (simplification)
             execute_fighter_action(game_state, FighterName.PLAYER, player_action)
        else:
            game_state.log_event(f"Player tried {player_action.value} but was busy with {game_state.player.current_action.value}")


    # Process AI action (AI might act based on a timer or reaction, simplified here)
    # For a more turn-based feel in testing, AI could act after player or on its own "turn"
    # For real-time, AI decision could be more frequent or reactive.
    if game_state.opponent.current_action == ActionType.IDLE: # AI acts if idle
        ai_action_choice = decide_ai_action(game_state)
        if ai_action_choice != ActionType.IDLE:
            execute_fighter_action(game_state, FighterName.OPPONENT, ai_action_choice)

    # Reset actions that are not meant to be persistent states after some time
    # (This is a very rough way to handle action durations)
    action_duration_limit = 0.5 # seconds
    if game_state.player.current_action not in [ActionType.IDLE, ActionType.BLOCK] and \
       (current_time - game_state.player.action_start_time > action_duration_limit):
        game_state.player.current_action = ActionType.IDLE

    if game_state.opponent.current_action not in [ActionType.IDLE, ActionType.BLOCK] and \
       (current_time - game_state.opponent.action_start_time > action_duration_limit):
        game_state.opponent.current_action = ActionType.IDLE


    # Check for end of round by time
    if game_state.round_timer <= 0:
        end_round_due_to_time(game_state)
        if game_state.match_status != GameStatus.MATCH_OVER:
             game_state.between_rounds_timer = 5 # 5 seconds rest
        return

    # Log game state periodically for debugging if needed
    # print(f"Tick: P_HP:{game_state.player.hp:.0f} P_SP:{game_state.player.stamina:.0f} ({game_state.player.current_action.value}) | "
    #       f"O_HP:{game_state.opponent.hp:.0f} O_SP:{game_state.opponent.stamina:.0f} ({game_state.opponent.current_action.value}) | "
    #       f"Timer: {game_state.round_timer:.1f}s")


if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing Game Tick (Simulated Loop) ---")
    game = initialize_new_game()
    start_new_round(game)

    # Simulate a game loop for a short duration
    sim_duration = 15 # Simulate for 15 seconds
    start_time = time.time()
    loop_count = 0

    # Simulate some player inputs over time
    # (In a real game, these would come from user interaction)
    if sim_duration > 2: time.eval('PLAYER_ACTION_QUEUE.append(ActionType.JAB)',  globals={'PLAYER_ACTION_QUEUE': PLAYER_ACTION_QUEUE, 'ActionType': ActionType}, locals={}) # Incorrect use of time.eval
    # Correct way for delayed actions in simulation:
    # We'll just add them periodically in the loop for this test.

    print(f"\nStarting {sim_duration}s simulation of game ticks...")
    game.last_tick_time = time.time() # Initialize last_tick_time before first tick

    while time.time() - start_time < sim_duration and game.match_status != GameStatus.MATCH_OVER:
        loop_count += 1
        # Simulate player input at intervals
        if loop_count % 20 == 5: # Every ~2 seconds if tick is ~0.1s
            queue_player_action_for_tick(ActionType.JAB)
            print("*** Player queued JAB ***")
        if loop_count % 30 == 0:
            queue_player_action_for_tick(ActionType.BLOCK)
            print("*** Player queued BLOCK ***")
        if loop_count % 50 == 0 and game.player.current_action == ActionType.BLOCK: # Unblock
             PLAYER_ACTION_QUEUE.append(ActionType.IDLE) # Crude way to stop blocking
             print("*** Player queued IDLE (to stop block) ***")


        game_tick(game)

        # Print summary less frequently to avoid flooding console
        if loop_count % 10 == 0:
             print(f"Tick {loop_count}: P_HP:{game.player.hp:.0f} P_SP:{game.player.stamina:.0f} ({game.player.current_action.value}) | "
                   f"O_HP:{game.opponent.hp:.0f} O_SP:{game.opponent.stamina:.0f} ({game.opponent.current_action.value}) | "
                   f"Timer: {game.round_timer:.1f}s | Knockdown: {game.knockdown_info['is_knockdown']} ({game.knockdown_info['count']:.1f})")

        time.sleep(0.1) # Simulate time passing between ticks

    print(f"\nSimulation ended after {time.time() - start_time:.2f}s and {loop_count} ticks.")
    print(f"Final Game Status: {game.match_status.value}")
    if game.winner:
        print(f"Winner: {game.winner if isinstance(game.winner, str) else game.winner.value}")
    print(f"Player HP: {game.player.hp}, Stamina: {game.player.stamina}")
    print(f"Opponent HP: {game.opponent.hp}, Stamina: {game.opponent.stamina}")


# --- Helper for Deserialization (New for DynamoDB integration) ---
def create_fighter_from_dict(data: dict, name_enum: FighterName) -> Fighter:
    """Creates a Fighter instance from a dictionary (e.g., from DynamoDB)."""
    if not data:
        return None

    fighter = Fighter(name_enum) # Use the name_enum for correct FighterName
    fighter.hp = data.get("hp", MAX_HP)
    fighter.max_hp = data.get("max_hp", MAX_HP) # Should ideally be same as MAX_HP
    fighter.stamina = data.get("stamina", MAX_STAMINA)
    fighter.max_stamina = data.get("max_stamina", MAX_STAMINA) # Should be MAX_STAMINA
    fighter.knockdowns_this_round = data.get("knockdowns_this_round", 0)
    fighter.total_knockdowns = data.get("total_knockdowns", 0)

    current_action_str = data.get("current_action", "IDLE")
    try:
        fighter.current_action = ActionType[current_action_str]
    except KeyError:
        fighter.current_action = ActionType.IDLE # Default if invalid string

    fighter.action_start_time = data.get("action_start_time", 0) # May not be in older saves

    # Stats deserialization: ensure enum keys are handled if they were stored as strings
    raw_stats = data.get("stats", {})
    fighter.stats = create_empty_fighter_stats() # Start with a clean slate
    for k, v in raw_stats.items():
        try:
            action_key = ActionType[k] # If key is an ActionType string
            fighter.stats[action_key] = v
        except KeyError:
            fighter.stats[k] = v # For non-ActionType keys like "punches_thrown"

    fighter.round_scores = data.get("round_scores", [])
    return fighter

def create_gamestate_from_dict(data: dict) -> GameState:
    """Creates a GameState instance from a dictionary (e.g., from DynamoDB)."""
    if not data:
        return None

    game_state = GameState() # Creates player/opponent with defaults

    game_state.game_id = data.get("game_id") # Assuming game_id is stored at top level

    try:
        game_state.match_status = GameStatus[data.get("match_status", "PENDING")]
    except KeyError:
        game_state.match_status = GameStatus.PENDING

    game_state.current_round = data.get("current_round", 0)
    game_state.max_rounds = data.get("max_rounds", MAX_ROUNDS) # Should be MAX_ROUNDS
    game_state.round_timer = data.get("round_timer", ROUND_DURATION_SECONDS)
    game_state.is_round_active = data.get("is_round_active", False)
    game_state.between_rounds_timer = data.get("between_rounds_timer", 0)

    winner_val = data.get("winner")
    if winner_val:
        if winner_val == "draw":
            game_state.winner = "draw"
        else:
            try:
                game_state.winner = FighterName[winner_val]
            except KeyError:
                game_state.winner = None # Or log an error
    else:
        game_state.winner = None

    # Deserialize player and opponent
    player_data = data.get("player")
    if player_data:
        game_state.player = create_fighter_from_dict(player_data, FighterName.PLAYER)

    opponent_data = data.get("opponent")
    if opponent_data:
        game_state.opponent = create_fighter_from_dict(opponent_data, FighterName.OPPONENT)

    # Deserialize knockdown_info
    kd_info_data = data.get("knockdown_info", {})
    game_state.knockdown_info["is_knockdown"] = kd_info_data.get("is_knockdown", False)
    kd_fighter_str = kd_info_data.get("fighter_down")
    if kd_fighter_str:
        try:
            game_state.knockdown_info["fighter_down"] = FighterName[kd_fighter_str]
        except KeyError:
            game_state.knockdown_info["fighter_down"] = None
    else:
        game_state.knockdown_info["fighter_down"] = None
    game_state.knockdown_info["count"] = kd_info_data.get("count", 0)

    game_state.event_log = data.get("event_log", []) # Assumes event log is stored as list of strings
    game_state.last_tick_time = data.get("last_tick_time", time.time()) # Default to now if not present

    return game_state


# --- Placeholder Functions for API Interaction ---

def handle_start_game_request():
    """
    Placeholder for what might be called when a web server receives a 'start game' request.
    Returns the initial game state.
    """
    game = initialize_new_game()
    # In a real API, this would likely be stored in a session or database
    # and an ID returned to the client.
    # For now, we just return the object.
    print("[API Placeholder] handle_start_game_request called.")
    return game # Or a serializable version of game_state

def handle_player_action_request(current_game_state: GameState, player_action_data: dict):
    """
    Placeholder for processing a player's action received from the web front-end.
    `player_action_data` might be a dict like {"action": "JAB"}
    Updates `current_game_state` and potentially returns it or a status.
    """
    action_str = player_action_data.get("action")
    try:
        action = ActionType[action_str.upper()] # Convert string to ActionType enum
        print(f"[API Placeholder] Received player action: {action.value}")
        # In a real game, this action would be queued or processed by the game loop.
        # For direct testing, we can queue it for our test game_tick.
        if current_game_state.match_status == GameStatus.ACTIVE and current_game_state.is_round_active:
            queue_player_action_for_tick(action) # Uses the global test queue
            # execute_fighter_action(current_game_state, FighterName.PLAYER, action) # Alternative direct execution
            return {"status": "success", "message": f"Action {action.value} received and queued."}
        else:
            return {"status": "error", "message": "Game not active or round not active."}
    except KeyError:
        print(f"[API Placeholder] Invalid action string received: {action_str}")
        return {"status": "error", "message": f"Invalid action: {action_str}"}
    except Exception as e:
        print(f"[API Placeholder] Error processing action: {e}")
        return {"status": "error", "message": f"Error processing action: {str(e)}"}


def handle_get_game_state_request(current_game_state: GameState):
    """
    Placeholder for when the front-end requests the current game state.
    Returns a serializable version of the game state.
    """
    print("[API Placeholder] handle_get_game_state_request called.")
    # This would need to serialize the GameState object to JSON,
    # including nested Fighter objects and their stats.
    # For now, just returning the object directly.
    return current_game_state # Or a serialized_game_state


if __name__ == '__main__':
    # ... (previous test code remains) ...

    print("\n--- Testing API Placeholder Functions ---")
    # 1. Test starting a game
    game_instance_api = handle_start_game_request()
    assert game_instance_api.match_status == GameStatus.PENDING # Initial state before round starts
    print(f"Initial API game state HP: P:{game_instance_api.player.hp} O:{game_instance_api.opponent.hp}")

    # Manually start the first round for this test instance
    start_new_round(game_instance_api)
    print(f"Game state after starting round: {game_instance_api.match_status}")


    # 2. Test sending a player action
    action_data = {"action": "JAB"}
    response = handle_player_action_request(game_instance_api, action_data)
    print(f"API response to JAB action: {response}")
    assert response["status"] == "success"
    assert PLAYER_ACTION_QUEUE[-1] == ActionType.JAB # Check if it was added to our test queue

    # Simulate a game tick to process the queued action for this separate game_instance_api
    if PLAYER_ACTION_QUEUE: # Ensure the queue specific to this test path is processed
        game_instance_api.last_tick_time = time.time() # Initialize tick time for this instance
        game_tick(game_instance_api)
        print(f"API game state after JAB and tick: P HP: {game_instance_api.player.hp}, O HP: {game_instance_api.opponent.hp}")
        assert game_instance_api.opponent.hp < MAX_HP or not ACTION_DETAILS[ActionType.JAB]["accuracy"] # Opponent took damage or jab missed

    PLAYER_ACTION_QUEUE.clear() # Clear queue for next test

    action_data_invalid = {"action": "FLY"}
    response_invalid = handle_player_action_request(game_instance_api, action_data_invalid)
    print(f"API response to FLY action: {response_invalid}")
    assert response_invalid["status"] == "error"

    # 3. Test getting game state
    retrieved_state = handle_get_game_state_request(game_instance_api)
    assert retrieved_state.current_round == 1
    print(f"Retrieved game state round: {retrieved_state.current_round}, Player HP: {retrieved_state.player.hp}")


# Next steps: Implement Round/Match progression, AI, and game loop (game_tick)
# The agent will then call plan_step_complete.
