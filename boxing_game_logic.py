import enum
import time # For game tick simulation later
import random # For AI and hit chances
import copy # For deep copying stats dicts

# --- Global Data Log ---
GAME_DATA_LOG = []

def clear_game_data_log():
    """Clears the global game data log."""
    global GAME_DATA_LOG
    GAME_DATA_LOG = []

def get_game_data_log():
    """Returns the global game data log."""
    global GAME_DATA_LOG
    return GAME_DATA_LOG

# --- Constants ---
MAX_HP = 100
MAX_STAMINA = 100
ROUND_DURATION_SECONDS = 90
MAX_ROUNDS = 3
STAMINA_REGEN_PER_SECOND = 5
STAMINA_REGEN_BETWEEN_ROUNDS = 25
KNOCKDOWN_COUNT_MAX = 10

# --- Enums ---
class ActionType(enum.Enum):
    JAB = "JAB"
    CROSS = "CROSS"
    HOOK = "HOOK"
    UPPERCUT = "UPPERCUT"
    BLOCK = "BLOCK"
    DODGE = "DODGE"
    ADVANCE = "ADVANCE"
    RETREAT = "RETREAT"
    SIDESTEP_LEFT = "SIDESTEP_LEFT"
    SIDESTEP_RIGHT = "SIDESTEP_RIGHT"
    IDLE = "IDLE" # When no specific action is being taken

class GameStatus(enum.Enum):
    PENDING = "pending"
    ACTIVE = "active"
    PAUSED = "paused"
    ROUND_OVER = "round_over"
    BETWEEN_ROUNDS = "between_rounds"
    MATCH_OVER = "match_over"

class FighterName(enum.Enum):
    PLAYER = "Player"
    OPPONENT = "Opponent"

# --- Action Details (similar to JavaScript ACTION_DETAILS) ---
# Using a dictionary for now, could be attributes of ActionType enum members if preferred
ACTION_DETAILS = {
    ActionType.JAB: {"damage": 5, "stamina_cost": 5, "speed": 8, "accuracy": 0.85},
    ActionType.CROSS: {"damage": 10, "stamina_cost": 10, "speed": 6, "accuracy": 0.75},
    ActionType.HOOK: {"damage": 12, "stamina_cost": 15, "speed": 5, "accuracy": 0.70},
    ActionType.UPPERCUT: {"damage": 15, "stamina_cost": 20, "speed": 4, "accuracy": 0.65},
    ActionType.BLOCK: {"stamina_cost_on_hit": 3, "stamina_cost_active_drain": 0.5}, # Example: cost when hit, and small drain if held
    ActionType.DODGE: {"stamina_cost": 10},
    ActionType.IDLE: {"damage": 0, "stamina_cost": 0, "speed": 0, "accuracy": 0.0}
    # Movement actions don't have damage/accuracy in the same way, handle separately
}

if __name__ == '__main__':
    # Example usage of Enums and Constants
    print(f"Max HP: {MAX_HP}")
    print(f"Jab Action: {ActionType.JAB}, Damage: {ACTION_DETAILS[ActionType.JAB]['damage']}")
    print(f"Game Initial Status: {GameStatus.PENDING.value}")

# Next steps will be to define Fighter and GameState classes.
# This file will be expanded as we go through the plan.

# --- Helper function for fighter stats ---
def create_empty_fighter_stats():
    return {
        "punches_thrown": 0,
        "punches_landed": 0,
        "damage_dealt": 0,
        ActionType.JAB: {"thrown": 0, "landed": 0},
        ActionType.CROSS: {"thrown": 0, "landed": 0},
        ActionType.HOOK: {"thrown": 0, "landed": 0},
        ActionType.UPPERCUT: {"thrown": 0, "landed": 0},
        "knockdowns_scored": 0
    }

# --- Classes ---
class Fighter:
    def __init__(self, name: FighterName):
        self.name = name
        self.hp = MAX_HP
        self.max_hp = MAX_HP
        self.stamina = MAX_STAMINA
        self.max_stamina = MAX_STAMINA
        self.knockdowns_this_round = 0
        self.total_knockdowns = 0
        self.current_action = ActionType.IDLE
        self.action_start_time = 0 # To time actions like blocking
        self.stats = create_empty_fighter_stats()
        self.round_scores = [] # List to store points awarded per round
        # self.position = {"x": 0, "y": 0, "z": 0} # Basic position if needed later

    def __str__(self):
        return f"{self.name.value} (HP: {self.hp}/{self.max_hp}, SP: {self.stamina}/{self.max_stamina})"

    def can_perform_action(self, action_type: ActionType) -> bool:
        if action_type not in ACTION_DETAILS:
            return True # For non-stamina costing actions like IDLE or movement (cost handled elsewhere if any)
        action_cost = ACTION_DETAILS[action_type].get("stamina_cost", 0)
        return self.stamina >= action_cost and self.hp > 0

    def apply_damage(self, damage: int):
        self.hp = max(0, self.hp - damage)

    def consume_stamina(self, cost: int):
        self.stamina = max(0, self.stamina - cost)

    def regenerate_stamina(self, amount: int):
        if self.hp > 0: # Cannot regenerate if knocked out
            self.stamina = min(self.max_stamina, self.stamina + amount)

    def reset_for_new_round(self):
        self.knockdowns_this_round = 0
        # Stamina is regenerated by the game state logic between rounds typically

    def record_action_stat(self, action_type: ActionType, landed: bool, damage_dealt: int = 0):
        self.stats["punches_thrown"] += 1
        if action_type in [ActionType.JAB, ActionType.CROSS, ActionType.HOOK, ActionType.UPPERCUT]:
            self.stats[action_type]["thrown"] += 1
            if landed:
                self.stats["punches_landed"] += 1
                self.stats[action_type]["landed"] += 1
                self.stats["damage_dealt"] += damage_dealt


class GameState:
    def __init__(self):
        self.match_status = GameStatus.PENDING
        self.current_round = 0
        self.max_rounds = MAX_ROUNDS
        self.round_timer = ROUND_DURATION_SECONDS # Seconds remaining in current round
        self.is_round_active = False
        self.between_rounds_timer = 0
        self.winner = None  # FighterName or "draw"

        self.player = Fighter(FighterName.PLAYER)
        self.opponent = Fighter(FighterName.OPPONENT) # Basic AI for now

        self.knockdown_info = {
            "is_knockdown": False,
            "fighter_down": None, # FighterName
            "count": 0
        }
        self.event_log = []
        self.last_tick_time = 0

    def __str__(self):
        return (f"Round: {self.current_round}/{self.max_rounds}, Timer: {self.round_timer:.1f}s, "
                f"Status: {self.match_status.value}\n"
                f"Player: {self.player}\nOpponent: {self.opponent}")

    def log_event(self, message: str):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        log_entry = f"[{timestamp}] {message}"
        # print(log_entry) # For real-time feedback during development - can be noisy with data logging
        self.event_log.append(log_entry)
        if len(self.event_log) > 100: # Keep log from growing too large
            self.event_log.pop(0)

    def get_fighter_by_name(self, name: FighterName) -> Fighter:
        if name == FighterName.PLAYER:
            return self.player
        return self.opponent

if __name__ == '__main__':
    # Example usage of Enums and Constants
    print(f"Max HP: {MAX_HP}")
    print(f"Jab Action: {ActionType.JAB}, Damage: {ACTION_DETAILS[ActionType.JAB]['damage']}")
    print(f"Game Initial Status: {GameStatus.PENDING.value}")

    # Test class instantiation
    player = Fighter(FighterName.PLAYER)
    opponent = Fighter(FighterName.OPPONENT)
    game = GameState()
    print(player)
    print(opponent)
    print(game)
    game.log_event("Game initialized.")
    print(f"Player can Jab: {player.can_perform_action(ActionType.JAB)}")
    player.consume_stamina(ACTION_DETAILS[ActionType.JAB]['stamina_cost'])
    print(f"Player stamina after Jab: {player.stamina}")
    player.apply_damage(30)
    print(f"Player HP after taking damage: {player.hp}")

# --- Core Game Mechanics ---

def initialize_new_game() -> GameState:
    """Creates and returns a fresh GameState instance."""
    game = GameState()
    game.log_event("New game initialized.")
    # Potential further setup: e.g., set opponent AI profile if we have different types
    _log_game_state_data(game, event_trigger="initialize_new_game")
    return game

def _log_game_state_data(game_state: GameState, event_trigger: str, action_taken: ActionType = None, acting_fighter: FighterName = None):
    """Helper function to create and append a structured log entry."""
    if not hasattr(game_state, 'game_id'): # Ensure game_id attribute exists for logging consistency
        game_state.game_id = "sim_game" # Default for simulations if not set externally

    log_entry = {
        "game_id": game_state.game_id,
        "log_timestamp": time.time(), # Real timestamp of logging
        "sim_time_elapsed": (game_state.last_tick_time - getattr(game_state, '_start_time_for_sim_elapsed', game_state.last_tick_time)) if hasattr(game_state, 'last_tick_time') else 0,
        "current_round": game_state.current_round,
        "round_timer": round(game_state.round_timer, 2) if game_state.round_timer is not None else None,
        "match_status": game_state.match_status.value,
        "player_hp": game_state.player.hp,
        "player_stamina": round(game_state.player.stamina, 2),
        "player_current_action": game_state.player.current_action.value,
        "player_stats": copy.deepcopy(game_state.player.stats), # Deep copy to avoid issues with dicts of dicts
        "opponent_hp": game_state.opponent.hp,
        "opponent_stamina": round(game_state.opponent.stamina, 2),
        "opponent_current_action": game_state.opponent.current_action.value,
        "opponent_stats": copy.deepcopy(game_state.opponent.stats),
        "knockdown_is_active": game_state.knockdown_info["is_knockdown"],
        "knockdown_fighter_down": game_state.knockdown_info["fighter_down"].value if game_state.knockdown_info["fighter_down"] else None,
        "knockdown_count": round(game_state.knockdown_info["count"], 2),
        "event_trigger": event_trigger,
        "action_taken_by_player": None,
        "action_taken_by_opponent": None,
        "winner": game_state.winner.value if isinstance(game_state.winner, FighterName) else game_state.winner if isinstance(game_state.winner, str) else None,
    }
    # Convert ActionType keys in stats to strings for easier serialization (e.g., to JSON/CSV)
    for fighter_stats_key in ["player_stats", "opponent_stats"]:
        stats_dict = log_entry[fighter_stats_key]
        new_stats_dict = {}
        for k, v in stats_dict.items():
            if isinstance(k, ActionType):
                new_stats_dict[k.value] = v
            else:
                new_stats_dict[k] = v
        log_entry[fighter_stats_key] = new_stats_dict


    if acting_fighter == FighterName.PLAYER and action_taken:
        log_entry["action_taken_by_player"] = action_taken.value
    elif acting_fighter == FighterName.OPPONENT and action_taken:
        log_entry["action_taken_by_opponent"] = action_taken.value

    GAME_DATA_LOG.append(log_entry)


def execute_fighter_action(game_state: GameState, attacker_name: FighterName, action_type: ActionType):
    """
    Handles the execution of an action by a fighter (player or opponent).
    Updates game state based on the action (damage, stamina, stats, knockdowns).
    """
    attacker = game_state.get_fighter_by_name(attacker_name)
    defender_name = FighterName.OPPONENT if attacker_name == FighterName.PLAYER else FighterName.PLAYER
    defender = game_state.get_fighter_by_name(defender_name)

    pre_action_player_hp = game_state.player.hp # For logging if action fails
    pre_action_opponent_hp = game_state.opponent.hp

    if not attacker.can_perform_action(action_type):
        game_state.log_event(f"{attacker.name.value} tried {action_type.value} but couldn't (low stamina/HP).")
        attacker.current_action = ActionType.IDLE # Ensure action is reset
        # Log state even if action failed to execute
        _log_game_state_data(game_state, event_trigger="action_failed_cannot_perform", action_taken=action_type, acting_fighter=attacker_name)
        return

    action_info = ACTION_DETAILS.get(action_type)
    if not action_info: # Movement or other non-combat actions
        attacker.current_action = action_type
        game_state.log_event(f"{attacker.name.value} performs {action_type.value}.")
        _log_game_state_data(game_state, event_trigger="fighter_movement", action_taken=action_type, acting_fighter=attacker_name)
        # Movement logic would be handled separately if it has specific effects on distance, etc.
        # For now, just log and set current_action. Stamina cost for movement can be added.
        return

    attacker.consume_stamina(action_info["stamina_cost"])
    attacker.current_action = action_type # Set current action before logging, but after stamina consumption
    attacker.action_start_time = time.time() # For timed actions like block

    game_state.log_event(f"{attacker.name.value} uses {action_type.value} (Stamina: {attacker.stamina})")
    attacker.record_action_stat(action_type, landed=False) # Initially record as thrown

    is_blocked = defender.current_action == ActionType.BLOCK
    # Basic hit chance calculation
    hit_roll = random.random()
    accuracy = action_info.get("accuracy", 0) # Default to 0 if no accuracy defined (e.g. for block)

    if action_type in [ActionType.JAB, ActionType.CROSS, ActionType.HOOK, ActionType.UPPERCUT]:
        if is_blocked:
            game_state.log_event(f"{defender.name.value} blocks the {action_type.value}!")
            defender.consume_stamina(ACTION_DETAILS[ActionType.BLOCK]["stamina_cost_on_hit"])
            # Potentially reduced "chip" damage even on block, or guard break mechanic later
            # For now, block negates damage fully.
            attacker.record_action_stat(action_type, landed=False) # Update: it was blocked, not landed on target HP
        elif hit_roll < accuracy:
            damage = action_info["damage"]
            defender.apply_damage(damage)
            attacker.record_action_stat(action_type, landed=True, damage_dealt=damage) # Update: landed
            game_state.log_event(
                f"{action_type.value} from {attacker.name.value} lands! "
                f"{defender.name.value} HP: {defender.hp}"
            )
            if defender.hp <= 0:
                # Knockdown will be handled, which will log its own event
                handle_knockdown(game_state, defender_name, attacker_name)
        else:
            game_state.log_event(f"{action_type.value} from {attacker.name.value} missed.")
            attacker.record_action_stat(action_type, landed=False) # Update: missed

    elif action_type == ActionType.BLOCK:
        # Block is a state. Its effect happens when an opponent attacks.
        # Stamina drain while active blocking can be handled in game_tick.
        pass # Logging for block initiation is covered by the generic log after this function
    elif action_type == ActionType.DODGE:
        # Dodge effect: if opponent attacks during dodge window, it's a miss.
        # Could also set up a counter-attack window.
        pass # Logging for dodge initiation is covered by the generic log

    # Log state after action execution
    # The acting_fighter's current_action is already set to action_type
    _log_game_state_data(game_state, event_trigger="fighter_action_resolved", action_taken=action_type, acting_fighter=attacker_name)

    # Reset attacker's action to IDLE after a short duration for non-continuous actions
    # Continuous actions like BLOCK will be managed by their own logic or by game_tick
    if action_type not in [ActionType.BLOCK]: # Block might persist
         # This is a simplification; in a real-time game, actions have durations.
         # For now, assume offensive actions are somewhat instant for turn-based processing.
        attacker.current_action = ActionType.IDLE # Reset after logging the action state


def handle_knockdown(game_state: GameState, downed_fighter_name: FighterName, attacker_name: FighterName):
    """Manages the knockdown sequence."""
    if game_state.knockdown_info["is_knockdown"]: # Another knockdown already in progress
        return

    downed_fighter = game_state.get_fighter_by_name(downed_fighter_name)
    attacker = game_state.get_fighter_by_name(attacker_name)

    downed_fighter.knockdowns_this_round += 1
    downed_fighter.total_knockdowns += 1
    attacker.stats["knockdowns_scored"] += 1

    game_state.knockdown_info["is_knockdown"] = True
    game_state.knockdown_info["fighter_down"] = downed_fighter_name
    game_state.knockdown_info["count"] = 0
    game_state.is_round_active = False # Pause round during knockdown count

    game_state.log_event(f"{downed_fighter.name.value} is KNOCKED DOWN by {attacker.name.value}!")
    _log_game_state_data(game_state, event_trigger="knockdown_start", acting_fighter=attacker_name)


    # TKO Check: 3 knockdowns in a round
    if downed_fighter.knockdowns_this_round >= 3:
        game_state.log_event(f"Three knockdowns in this round! {attacker.name.value} wins by TKO!")
        game_state.winner = attacker.name
        # game_state.match_status = GameStatus.MATCH_OVER # This will be set by end_match
        # end_match(game_state) will be called from game_tick which will log the match_over state
        _log_game_state_data(game_state, event_trigger="tko_knockdown_limit") # Log TKO specifically
        return # Match ends here due to TKO

    # The actual 10-count will be managed by game_tick or a similar time-based update function.
    # For now, this function sets up the state for that.

if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing Core Mechanics ---")
    game = initialize_new_game()
    print(game)

    # Player Jabs Opponent
    execute_fighter_action(game, FighterName.PLAYER, ActionType.JAB)
    print(game)
    # Opponent Jabs Player
    execute_fighter_action(game, FighterName.OPPONENT, ActionType.JAB)
    print(game)

    # Player blocks, Opponent Jabs
    game.player.current_action = ActionType.BLOCK # Manually set player to block for test
    game.player.action_start_time = time.time()
    game.log_event(f"{game.player.name.value} is now blocking.")
    execute_fighter_action(game, FighterName.OPPONENT, ActionType.JAB)
    print(game)
    game.player.current_action = ActionType.IDLE # Reset block

    # Simulate player knocking down opponent
    game.opponent.hp = ACTION_DETAILS[ActionType.CROSS]["damage"] # Set HP to be knocked out by one cross
    game.log_event(f"Setting opponent HP to {game.opponent.hp} for knockdown test.")
    execute_fighter_action(game, FighterName.PLAYER, ActionType.CROSS)
    print(game)
    print(f"Knockdown info: {game.knockdown_info}")
    if game.winner:
        print(f"Winner after knockdown test: {game.winner.value}")

# --- Round and Match Progression ---

def start_new_round(game_state: GameState):
    """Initializes settings for the start of a new round."""
    game_state.current_round += 1
    game_state.is_round_active = True
    game_state.match_status = GameStatus.ACTIVE
    game_state.round_timer = ROUND_DURATION_SECONDS

    game_state.player.reset_for_new_round()
    game_state.opponent.reset_for_new_round()

    # Regenerate some stamina between rounds
    game_state.player.regenerate_stamina(STAMINA_REGEN_BETWEEN_ROUNDS)
    game_state.opponent.regenerate_stamina(STAMINA_REGEN_BETWEEN_ROUNDS)

    game_state.knockdown_info["is_knockdown"] = False # Ensure no carry-over knockdown state
    game_state.knockdown_info["fighter_down"] = None
    game_state.knockdown_info["count"] = 0

    game_state.log_event(
        f"Round {game_state.current_round} starting! Player SP: {game_state.player.stamina}, Opponent SP: {game_state.opponent.stamina}"
    )
    if not hasattr(game_state, '_start_time_for_sim_elapsed'): # Initialize if not present
        game_state._start_time_for_sim_elapsed = time.time()
    game_state.last_tick_time = time.time() # Reset tick timer for the new round
    _log_game_state_data(game_state, event_trigger="start_new_round")


def end_round_due_to_time(game_state: GameState):
    """Handles the end of a round when the timer expires."""
    game_state.is_round_active = False
    game_state.log_event(f"Round {game_state.current_round} has ended due to time.")

    score_round(game_state) # Assign points for the completed round
    _log_game_state_data(game_state, event_trigger="round_end_time")


    if game_state.current_round >= game_state.max_rounds:
        game_state.log_event("Maximum rounds reached.")
        end_match(game_state) # This will also log
    else:
        game_state.match_status = GameStatus.BETWEEN_ROUNDS
        game_state.log_event("Proceeding to next round shortly.")
        _log_game_state_data(game_state, event_trigger="between_rounds_start")
        # A delay or specific trigger would start the next round in a full game loop

def end_match(game_state: GameState):
    """Finalizes the match, determining a winner if not already set by KO/TKO."""
    game_state.is_round_active = False # Ensure no further actions
    game_state.match_status = GameStatus.MATCH_OVER
    final_winner_log_message = ""

    if game_state.winner: # Winner already determined by KO/TKO
        final_winner_log_message = f"Match ended. Winner by KO/TKO: {game_state.winner.value}"
        game_state.log_event(final_winner_log_message)
    else: # Match ended by rounds completing, determine by decision
        determine_winner_by_decision(game_state) # This sets game_state.winner
        if game_state.winner and game_state.winner != "draw":
            final_winner_log_message = f"Match ended. Winner by decision: {game_state.winner.value}"
            game_state.log_event(final_winner_log_message)
        elif game_state.winner == "draw":
            final_winner_log_message = "Match ended in a DRAW by decision."
            game_state.log_event(final_winner_log_message)
        else: # Should not happen if determine_winner_by_decision works
            final_winner_log_message = "Match ended by rounds, winner determination pending or error."
            game_state.log_event(final_winner_log_message)

    _log_game_state_data(game_state, event_trigger="match_end")


    # Further actions: display final stats, offer rematch, etc.

def score_round(game_state: GameState):
    """
    Scores the completed round based on performance (simplified for now).
    Uses a 10-point must system.
    """
    player_score = 0
    opponent_score = 0

    # Simplified criteria: damage dealt. More complex: punches landed, aggression, defense.
    # For this example, let's assume we need to sum damage dealt *in this specific round*.
    # The current stats are cumulative, so this needs refinement if we want per-round exactness for scoring.
    # For now, we'll use total damage as a proxy.

    # This is a placeholder. Proper round scoring would require tracking stats per round.
    # Let's use a proxy: whoever has more HP at the end of the round, or dealt more relative damage.
    # Or, more simply, award based on knockdowns primarily.

    if game_state.player.stats["damage_dealt"] > game_state.opponent.stats["damage_dealt"]: # Placeholder for actual round performance
        player_score = 10
        opponent_score = 9
    elif game_state.opponent.stats["damage_dealt"] > game_state.player.stats["damage_dealt"]:
        opponent_score = 10
        player_score = 9
    else: # Equal performance or no clear winner based on this simple metric
        player_score = 10 # Could be 9-9 for some judging styles for an even round
        opponent_score = 10

    # Adjust for knockdowns in the round
    # Player knocked down opponent
    player_knockdowns_on_opponent = game_state.opponent.knockdowns_this_round
    # opponent_knockdowns_on_player = game_state.player.knockdowns_this_round

    # This logic is a bit confusing. Let's simplify:
    # If player scored knockdowns, opponent score is reduced.
    # If opponent scored knockdowns, player score is reduced.

    # Score for player: 10 (base if won round) or 9 (base if lost round)
    # Score for opponent: 10 (base if won round) or 9 (base if lost round)

    # Example: if player won the round (10-9), but was knocked down once, it becomes 9-9.
    # If player won round (10-9) and knocked opponent down once, it becomes 10-8 for player.

    # Let's use a simpler direct assignment based on who did better, then adjust.
    # Assume player_score and opponent_score are initially 0.
    # The "10-point must" system: winner of round gets 10, loser gets 9.
    # Exception: if loser is knocked down, they get 8. If knocked down twice, 7.

    # Simplified scoring:
    # 1. Determine round winner (e.g. based on damage, aggression - very basic for now)
    p_round_damage = game_state.player.stats["damage_dealt"] # This is total, not per-round, needs fixing for real scoring
    o_round_damage = game_state.opponent.stats["damage_dealt"]

    round_winner = None
    if p_round_damage > o_round_damage : round_winner = game_state.player
    elif o_round_damage > p_round_damage : round_winner = game_state.opponent

    if round_winner == game_state.player:
        player_score = 10
        opponent_score = 9 - game_state.opponent.knockdowns_this_round # if opponent was knocked down
        if game_state.opponent.knockdowns_this_round > 0 : opponent_score = max(7, 9 - game_state.opponent.knockdowns_this_round) # Min score usually 7
        else: opponent_score = 9
        if game_state.player.knockdowns_this_round > 0: # If player won round but was also knocked down
            player_score = max(7, 10 - game_state.player.knockdowns_this_round)

    elif round_winner == game_state.opponent:
        opponent_score = 10
        player_score = 9 - game_state.player.knockdowns_this_round # if player was knocked down
        if game_state.player.knockdowns_this_round > 0: player_score = max(7, 9 - game_state.player.knockdowns_this_round)
        else: player_score = 9
        if game_state.opponent.knockdowns_this_round > 0: # If opponent won round but was also knocked down
            opponent_score = max(7, 10 - game_state.opponent.knockdowns_this_round)
    else: # Even round
        player_score = 10 - game_state.player.knockdowns_this_round
        opponent_score = 10 - game_state.opponent.knockdowns_this_round
        player_score = max(7, player_score)
        opponent_score = max(7, opponent_score)


    game_state.player.round_scores.append(player_score)
    game_state.opponent.round_scores.append(opponent_score)
    game_state.log_event(
        f"Round {game_state.current_round} scored: Player {player_score}, Opponent {opponent_score}"
    )
    # Crucially, for accurate round-by-round scoring, stats like damage_dealt
    # would need to be reset or snapshotted at the start/end of each round.
    # The current Fighter.stats are cumulative for the whole match.

def determine_winner_by_decision(game_state: GameState):
    """Determines the winner based on accumulated round scores."""
    total_player_score = sum(game_state.player.round_scores)
    total_opponent_score = sum(game_state.opponent.round_scores)

    game_state.log_event(
        f"Decision: Player Total Score {total_player_score}, Opponent Total Score {total_opponent_score}"
    )

    if total_player_score > total_opponent_score:
        game_state.winner = game_state.player.name # Store FighterName enum
    elif total_opponent_score > total_player_score:
        game_state.winner = game_state.opponent.name # Store FighterName enum
    else:
        game_state.winner = "draw" # Special string for draw


if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing Round/Match Progression ---")
    game = initialize_new_game()

    # Simulate a few rounds
    for r in range(1, game.max_rounds + 1):
        start_new_round(game)
        print(game)
        # Simulate some actions in the round
        execute_fighter_action(game, FighterName.PLAYER, ActionType.JAB)
        execute_fighter_action(game, FighterName.OPPONENT, ActionType.JAB)
        if r == 1: # Player scores a knockdown in round 1
            game.opponent.hp = 1
            execute_fighter_action(game, FighterName.PLAYER, ActionType.JAB) # Knockdown
            # Manually advance knockdown count for testing since game_tick isn't running
            if game.knockdown_info["is_knockdown"]:
                 game.knockdown_info["count"] = KNOCKDOWN_COUNT_MAX -1 # Almost KO'd but gets up
                 game_state.log_event(f"{game.knockdown_info['fighter_down'].value} gets up at count {game.knockdown_info['count']}")
                 game.knockdown_info["is_knockdown"] = False
                 game.is_round_active = True # Resume round
                 game.opponent.hp = 20 # Recover some HP

        game.round_timer = 0 # End round by time
        end_round_due_to_time(game)
        if game.match_status == GameStatus.MATCH_OVER:
            break

    if game.match_status != GameStatus.MATCH_OVER: # Should be MATCH_OVER if all rounds played
        end_match(game) # Ensure match ends if loop finishes

    print(f"Final Player Scores: {game.player.round_scores}")
    print(f"Final Opponent Scores: {game.opponent.round_scores}")
    print(f"Match Winner: {game.winner if isinstance(game.winner, str) else game.winner.value if game.winner else 'N/A'}")


# --- AI Logic ---
# Attempt to import the prediction service for ML-based AI
try:
    import prediction_service
    ML_AI_AVAILABLE = True
    print("Successfully imported prediction_service for ML AI.")
except ImportError:
    ML_AI_AVAILABLE = False
    print("Warning: prediction_service not found. ML-based AI will not be available. Falling back to rule-based AI.")
    prediction_service = None # Ensure it's defined even if import fails

DEFAULT_AI_MODE = "RULE_BASED" # Can be "RULE_BASED" or "ML_BASED"

def decide_ai_action(game_state: GameState, ai_mode: str = DEFAULT_AI_MODE) -> ActionType:
    """
    AI decision-making logic for the opponent.
    Can use rule-based logic or an ML model via prediction_service.

    Args:
        game_state (GameState): The current state of the game.
        ai_mode (str): The mode of AI to use ("RULE_BASED" or "ML_BASED").
                       Defaults to DEFAULT_AI_MODE.

    Returns:
        ActionType: The action chosen by the AI.
    """
    opponent = game_state.opponent
    player = game_state.player # For rule-based part

    # Attempt to use ML-based AI if specified and available
    if ai_mode == "ML_BASED":
        if ML_AI_AVAILABLE and prediction_service.ACTION_MODEL is not None:
            game_state.log_event(f"Opponent AI attempting ML model for action decision. (Model: {'Loaded' if prediction_service.ACTION_MODEL else 'Not Loaded'})")
            predicted_action = prediction_service.predict_opponent_action(game_state)

            # Validate if the ML model's chosen action is performable
            if opponent.can_perform_action(predicted_action):
                game_state.log_event(f"ML AI chose valid action: {predicted_action.value}")
                return predicted_action
            else:
                game_state.log_event(f"ML AI chose unperformable action: {predicted_action.value}. Falling back to rule-based for this turn.")
                # Fallback to rule-based for this specific turn if ML action is invalid
                # This is better than just picking a random valid action, as rule-based has more logic.
                ai_mode = "RULE_BASED" # Force rule-based for this turn
        else:
            game_state.log_event("ML_BASED AI mode selected, but model or service is not available. Falling back to RULE_BASED.")
            ai_mode = "RULE_BASED" # Fallback to rule-based if ML components are missing

    # --- Rule-based AI (default or if ML fallback occurs) ---
    if ai_mode == "RULE_BASED":
        game_state.log_event("Opponent AI using rule-based logic for action decision.")
        # (Rest of the rule-based logic remains the same)
        possible_actions = []

        # Validate if the ML model's chosen action is performable
        if opponent.can_perform_action(predicted_action):
            game_state.log_event(f"ML AI chose valid action: {predicted_action.value}")
            return predicted_action
        else:
            game_state.log_event(f"ML AI chose unperformable action: {predicted_action.value}. Falling back.")
            # Fallback logic: could be to rule-based, or pick a random valid action, or just IDLE
            # For now, let's try a random valid offensive/defensive action or IDLE as a simpler fallback.
            valid_actions = [a for a in [ActionType.JAB, ActionType.CROSS, ActionType.BLOCK, ActionType.DODGE, ActionType.IDLE] if opponent.can_perform_action(a)]
            if valid_actions:
                fallback_action = random.choice(valid_actions)
                game_state.log_event(f"ML AI fallback to: {fallback_action.value}")
                return fallback_action
            else: # Should always be able to IDLE if HP > 0
                 game_state.log_event(f"ML AI fallback to IDLE (no other valid actions).")
                 return ActionType.IDLE

    # --- Rule-based AI (default or fallback) ---
    if ai_mode == "RULE_BASED" or not (ML_AI_AVAILABLE and prediction_service.ACTION_MODEL is not None) :
        if ai_mode == "ML_BASED": # Log if ML was intended but unavailable
             game_state.log_event("ML AI model not available, falling back to rule-based AI.")
        else: # Explicitly rule-based
            game_state.log_event("Opponent AI using rule-based logic for action decision.")

        possible_actions = []
        if not opponent.can_perform_action(ActionType.JAB) and \
           not opponent.can_perform_action(ActionType.CROSS) and \
           not opponent.can_perform_action(ActionType.BLOCK):
            return ActionType.IDLE

        if opponent.stamina < ACTION_DETAILS[ActionType.CROSS]["stamina_cost"]:
            if opponent.can_perform_action(ActionType.JAB): possible_actions.append(ActionType.JAB)
            if opponent.can_perform_action(ActionType.BLOCK): possible_actions.append(ActionType.BLOCK)
            if not possible_actions: return ActionType.IDLE
            return random.choice(possible_actions)

        if player.hp < MAX_HP * 0.3:
            if opponent.can_perform_action(ActionType.CROSS): possible_actions.append(ActionType.CROSS)
            if opponent.can_perform_action(ActionType.JAB): possible_actions.append(ActionType.JAB)

        for action in [ActionType.JAB, ActionType.CROSS, ActionType.HOOK, ActionType.UPPERCUT]:
            if opponent.can_perform_action(action): possible_actions.append(action)

        if opponent.can_perform_action(ActionType.BLOCK):
            if player.current_action not in [ActionType.IDLE, ActionType.BLOCK] or opponent.hp < MAX_HP * 0.5:
                possible_actions.extend([ActionType.BLOCK] * 3)
            else:
                possible_actions.append(ActionType.BLOCK)

        if opponent.can_perform_action(ActionType.DODGE): # Add dodge to possibilities
            possible_actions.append(ActionType.DODGE)

        if not possible_actions:
            # This should ideally not happen if IDLE is always possible or if can_perform_action(IDLE) is true
            game_state.log_event("Rule-based AI: No possible actions found, defaulting to IDLE.")
            return ActionType.IDLE

        chosen_action = random.choice(possible_actions)
        game_state.log_event(f"Rule-based AI chose action: {chosen_action.value}")
        return chosen_action

    # This part should ideally not be reached if ai_mode is one of the handled values.
    game_state.log_event(f"AI decision error: Unknown ai_mode '{ai_mode}'. Defaulting to IDLE.")
    return ActionType.IDLE


if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing AI Decision ---")
    # Setup for ML AI testing (mocking the prediction_service setup)
    if ML_AI_AVAILABLE:
        print("Attempting to set up mock action model for testing decide_ai_action with ML_BASED mode.")
        class MockActionModelLocal: # Renamed to avoid conflict if prediction_service also has MockActionModel
            def predict(self, X):
                # Simple mock: if self_hp is low, try to block, else jab.
                # Ensure ACTION_MODEL_LE_CLASSES is accessible, assume it's set in prediction_service
                le_classes = prediction_service.ACTION_MODEL_LE_CLASSES if prediction_service.ACTION_MODEL_LE_CLASSES else [act.value for act in ActionType]

                if 'self_hp' in X.columns and X['self_hp'].iloc[0] < 30 :
                    if ActionType.BLOCK.value in le_classes:
                        return np.array([le_classes.index(ActionType.BLOCK.value)])
                if ActionType.JAB.value in le_classes:
                    return np.array([le_classes.index(ActionType.JAB.value)])
                return np.array([0]) # Default to first class if JAB/BLOCK not found (should not happen with full list)

        mock_le_action_classes_main = [act.value for act in ActionType]
        # Feature order should match what preprocess_gamestate_for_action_prediction creates
        # Copied from prediction_service.py's __main__ for consistency
        mock_action_feature_order_main = [
            'self_hp', 'self_stamina', 'other_player_hp', 'other_player_stamina',
            'hp_diff_self_vs_other', 'stamina_diff_self_vs_other',
            'current_round', 'round_timer',
        ] + [f'other_player_action_{act_type_str}' for act_type_str in ['IDLE', 'JAB', 'CROSS', 'HOOK', 'UPPERCUT', 'BLOCK', 'DODGE', 'ADVANCE', 'RETREAT', 'SIDESTEP_LEFT', 'SIDESTEP_RIGHT']]
        mock_action_feature_order_main = sorted(list(set(mock_action_feature_order_main)))

        if prediction_service: # Ensure prediction_service was imported
            prediction_service.set_action_model_details(MockActionModelLocal(), mock_action_feature_order_main, mock_le_action_classes_main)
        else:
            print("Cannot set mock action model details: prediction_service is None.")
            ML_AI_AVAILABLE = False # Mark as unavailable if setup fails
    else:
        print("ML_AI_AVAILABLE is False, will only test RULE_BASED AI.")


    game = initialize_new_game()
    game.game_id = "ai_decision_test"
    start_new_round(game)

    print("\nTesting RULE_BASED AI:")
    for i in range(3):
        ai_action_rule = decide_ai_action(game, ai_mode="RULE_BASED")
        print(f"Rule-based AI decided: {ai_action_rule.value} (Stamina: {game.opponent.stamina}, HP: {game.opponent.hp})")
        # Simulate performing action to change state slightly for next decision
        if game.opponent.can_perform_action(ai_action_rule) and ai_action_rule not in [ActionType.IDLE, ActionType.BLOCK]:
            # Check if action has stamina_cost defined before trying to access it
            if ai_action_rule in ACTION_DETAILS and "stamina_cost" in ACTION_DETAILS[ai_action_rule]:
                 game.opponent.consume_stamina(ACTION_DETAILS[ai_action_rule]['stamina_cost'])
        elif ai_action_rule == ActionType.BLOCK:
            game.opponent.current_action = ActionType.BLOCK


    if ML_AI_AVAILABLE and prediction_service and prediction_service.ACTION_MODEL is not None:
        print("\nTesting ML_BASED AI:")
        game_ml = initialize_new_game() # Fresh game state for ML test
        game_ml.game_id = "ml_ai_decision_test"
        start_new_round(game_ml)
        game_ml.opponent.hp = 25 # Set low HP to test mock ML model's block logic

        for i in range(3):
            ai_action_ml = decide_ai_action(game_ml, ai_mode="ML_BASED")
            print(f"ML-based AI decided: {ai_action_ml.value} (Stamina: {game_ml.opponent.stamina}, HP: {game_ml.opponent.hp})")
            if game_ml.opponent.can_perform_action(ai_action_ml) and ai_action_ml not in [ActionType.IDLE, ActionType.BLOCK]:
                if ai_action_ml in ACTION_DETAILS and "stamina_cost" in ACTION_DETAILS[ai_action_ml]:
                    game_ml.opponent.consume_stamina(ACTION_DETAILS[ai_action_ml]['stamina_cost'])
            elif ai_action_ml == ActionType.BLOCK:
                game_ml.opponent.current_action = ActionType.BLOCK
            # Change player state to see if AI reacts
            game_ml.player.current_action = random.choice([ActionType.JAB, ActionType.IDLE])
            if i % 2 == 0 : game_ml.opponent.hp = min(100, game_ml.opponent.hp + 10) # vary hp
    else:
        print("\nSkipping ML_BASED AI test as it's not available or model not set.")


# --- Basic Game Loop Structure (for testing logic) ---

PLAYER_ACTION_QUEUE = [] # Global queue for player actions, for testing game_tick

def queue_player_action_for_tick(action: ActionType):
    """Adds a player action to the queue for game_tick to process."""
    PLAYER_ACTION_QUEUE.append(action)

def game_tick(game_state: GameState):
    """
    Simulates one tick or step of the game.
    Processes player inputs, AI actions, updates timers, checks conditions.
    This is a simplified version for testing the logic before API/WebSockets.
    """
    if game_state.match_status == GameStatus.MATCH_OVER:
        return # Game has ended

    current_time = time.time()
    delta_time = current_time - game_state.last_tick_time
    game_state.last_tick_time = current_time

    # Handle knockdown count
    if game_state.knockdown_info["is_knockdown"]:
        game_state.knockdown_info["count"] += delta_time # Increment count by time passed
        game_state.log_event(f"Knockdown count: {game_state.knockdown_info['count']:.1f}")
    # Log intermediate knockdown count state
    _log_game_state_data(game_state, event_trigger="knockdown_counting")

        if game_state.knockdown_info["count"] >= KNOCKDOWN_COUNT_MAX:
            downed_fighter_name = game_state.knockdown_info["fighter_down"]
            attacker_name = FighterName.PLAYER if downed_fighter_name == FighterName.OPPONENT else FighterName.OPPONENT

            game_state.log_event(f"{downed_fighter_name.value} is KNOCKED OUT!")
            game_state.winner = attacker_name
        # end_match will be called, which logs the final state
        _log_game_state_data(game_state, event_trigger="knockout") # Log KO specifically
            end_match(game_state)
            return # Match ends
        # No "getting up" mechanic yet if HP is 0. If HP > 0, could add it here.
    # For now, if not KO, assume fighter gets up if count is not max (implicitly handled by returning)
    # If we add a "get up" event, log it here.
    # if game_state.knockdown_info["count"] < KNOCKDOWN_COUNT_MAX and downed_fighter.hp > 0:
    # _log_game_state_data(game_state, event_trigger="fighter_recovered_from_knockdown_count")
    # This is tricky as "getting up" isn't an explicit event yet, rather an absence of KO.
    # The next tick will resume if is_knockdown is false.
        return # Pause other game logic during knockdown count

    if not game_state.is_round_active:
        if game_state.match_status == GameStatus.BETWEEN_ROUNDS:
            # Could have a timer for between_rounds state
            game_state.between_rounds_timer -= delta_time
            if game_state.between_rounds_timer <=0:
            start_new_round(game_state) # This will log "start_new_round"
            # No separate log here for between_rounds_end, as start_new_round covers it.
        return # Round not active (e.g., between rounds, paused)

    # Update round timer
    game_state.round_timer -= delta_time

    # Regenerate stamina for both fighters based on delta_time
    # STAMINA_REGEN_PER_SECOND is 'units per second', so multiply by delta_time
    game_state.player.regenerate_stamina(STAMINA_REGEN_PER_SECOND * delta_time)
    game_state.opponent.regenerate_stamina(STAMINA_REGEN_PER_SECOND * delta_time)

    # Active block stamina drain
    if game_state.player.current_action == ActionType.BLOCK:
        cost = ACTION_DETAILS[ActionType.BLOCK]["stamina_cost_active_drain"] * delta_time
        game_state.player.consume_stamina(cost)
        if not game_state.player.can_perform_action(ActionType.BLOCK): # No more stamina for block
            game_state.player.current_action = ActionType.IDLE
            game_state.log_event("Player block broke due to low stamina.")
    if game_state.opponent.current_action == ActionType.BLOCK:
        cost = ACTION_DETAILS[ActionType.BLOCK]["stamina_cost_active_drain"] * delta_time
        game_state.opponent.consume_stamina(cost)
        if not game_state.opponent.can_perform_action(ActionType.BLOCK):
            game_state.opponent.current_action = ActionType.IDLE
            game_state.log_event("Opponent block broke due to low stamina.")


    # Process Player action from queue (if any)
    if PLAYER_ACTION_QUEUE:
        player_action = PLAYER_ACTION_QUEUE.pop(0)
        # Check if player is stunned or otherwise unable to act (future enhancement)
        if game_state.player.current_action == ActionType.IDLE: # Can only act if idle (simplification)
         # execute_fighter_action will log the action outcome
             execute_fighter_action(game_state, FighterName.PLAYER, player_action)
        else:
            game_state.log_event(f"Player tried {player_action.value} but was busy with {game_state.player.current_action.value}")
        # Log this busy state
        _log_game_state_data(game_state, event_trigger="player_action_attempt_busy", action_taken=player_action)


    # Process AI action (AI might act based on a timer or reaction, simplified here)
    # For a more turn-based feel in testing, AI could act after player or on its own "turn"
    # For real-time, AI decision could be more frequent or reactive.
    if game_state.opponent.current_action == ActionType.IDLE and game_state.is_round_active and not game_state.knockdown_info["is_knockdown"]: # AI acts if idle and game is active
        ai_action_choice = decide_ai_action(game_state)
        if ai_action_choice != ActionType.IDLE:
            # execute_fighter_action will log the action outcome
            execute_fighter_action(game_state, FighterName.OPPONENT, ai_action_choice)
        # else: # AI chose IDLE
            # _log_game_state_data(game_state, event_trigger="ai_action_idle", action_taken=ActionType.IDLE, acting_fighter=FighterName.OPPONENT)


    # Reset actions that are not meant to be persistent states after some time
    # (This is a very rough way to handle action durations)
    # This reset happens *after* actions are logged for the tick by execute_fighter_action
    action_duration_limit = 0.5 # seconds
    if game_state.player.current_action not in [ActionType.IDLE, ActionType.BLOCK] and \
       (current_time - game_state.player.action_start_time > action_duration_limit):
        game_state.player.current_action = ActionType.IDLE

    if game_state.opponent.current_action not in [ActionType.IDLE, ActionType.BLOCK] and \
       (current_time - game_state.opponent.action_start_time > action_duration_limit):
        game_state.opponent.current_action = ActionType.IDLE


    # Check for end of round by time
    if game_state.round_timer <= 0:
        end_round_due_to_time(game_state)
        if game_state.match_status != GameStatus.MATCH_OVER:
             game_state.between_rounds_timer = 5 # 5 seconds rest
        return

    # Log game state periodically for debugging if needed (less frequent than every tick)
    # if hasattr(game_state, 'log_counter') and game_state.log_counter % 10 == 0: # Example: log every 10 ticks
    #    _log_game_state_data(game_state, event_trigger="periodic_tick_update")
    # game_state.log_counter = getattr(game_state, 'log_counter', 0) + 1


if __name__ == '__main__':
    # ... (previous test code remains) ...
    print("\n--- Testing Game Tick (Simulated Loop) ---")
    clear_game_data_log() # Clear log before new test run
    game = initialize_new_game()
    # Add a game_id for testing logging
    game.game_id = "test_game_tick_sim"
    game._start_time_for_sim_elapsed = time.time() # For sim_time_elapsed in log

    start_new_round(game)


    # Simulate a game loop for a short duration
    sim_duration = 5 # Simulate for 5 seconds to keep log small for review
    start_time = time.time()
    loop_count = 0

    # Simulate some player inputs over time
    # (In a real game, these would come from user interaction)
    # For this test, let's queue a few actions upfront
    queue_player_action_for_tick(ActionType.JAB)
    # queue_player_action_for_tick(ActionType.CROSS) # Will be busy after jab
    # queue_player_action_for_tick(ActionType.BLOCK)


    print(f"\nStarting {sim_duration}s simulation of game ticks...")
    game.last_tick_time = time.time() # Initialize last_tick_time before first tick
    game.log_counter = 0 # For periodic logging within tick if desired

    while time.time() - start_time < sim_duration and game.match_status != GameStatus.MATCH_OVER:
        loop_count += 1
        # Simulate player input at intervals
        if loop_count == 15: # Approx 1.5s in
            queue_player_action_for_tick(ActionType.CROSS)
            # print("*** Player queued CROSS ***")
        if loop_count == 25: # Approx 2.5s in
            queue_player_action_for_tick(ActionType.BLOCK)
            # print("*** Player queued BLOCK ***")
        if loop_count == 35 and game.player.current_action == ActionType.BLOCK: # Approx 3.5s in
             PLAYER_ACTION_QUEUE.append(ActionType.IDLE) # Crude way to stop blocking
             # print("*** Player queued IDLE (to stop block) ***")

        current_tick_start_time = time.time()
        game_tick(game) # This will now have internal logging calls

        # Print summary less frequently to avoid flooding console
        # if loop_count % 10 == 0: # Logging is now internal, this can be removed or kept for high-level summary
        #      print(f"Sim Tick {loop_count}: P_HP:{game.player.hp:.0f} P_SP:{game.player.stamina:.0f} ({game.player.current_action.value}) | "
        #            f"O_HP:{game.opponent.hp:.0f} O_SP:{game.opponent.stamina:.0f} ({game.opponent.current_action.value}) | "
        #            f"Timer: {game.round_timer:.1f}s | Knockdown: {game.knockdown_info['is_knockdown']} ({game.knockdown_info['count']:.1f})")

        # Ensure tick processing doesn't take longer than tick interval for simulation stability
        elapsed_tick_processing = time.time() - current_tick_start_time
        sleep_duration = max(0, 0.1 - elapsed_tick_processing) # Target 0.1s tick interval
        time.sleep(sleep_duration)


    print(f"\nSimulation ended after {time.time() - start_time:.2f}s and {loop_count} ticks.")
    print(f"Final Game Status: {game.match_status.value}")
    if game.winner:
        print(f"Winner: {game.winner if isinstance(game.winner, str) else game.winner.value if game.winner else 'N/A'}")
    print(f"Player HP: {game.player.hp}, Stamina: {game.player.stamina}")
    print(f"Opponent HP: {game.opponent.hp}, Stamina: {game.opponent.stamina}")

    # --- Output the collected game data log for review ---
    print(f"\n--- Collected Game Data Log (last {min(5, len(GAME_DATA_LOG))} entries) ---")
    for entry_idx, log_item in enumerate(get_game_data_log()[-5:]): # Print last 5 entries
        print(f"Entry {len(get_game_data_log()) - min(5, len(GAME_DATA_LOG)) + entry_idx}:")
        for key, value in log_item.items():
            if isinstance(value, dict): # Print nested stats dicts more cleanly
                print(f"  {key}:")
                for sub_key, sub_value in value.items():
                    print(f"    {sub_key}: {sub_value}")
            else:
                print(f"  {key}: {value}")
    print(f"Total log entries: {len(GAME_DATA_LOG)}")


# --- Helper for Deserialization (New for DynamoDB integration) ---
def create_fighter_from_dict(data: dict, name_enum: FighterName) -> Fighter:
    """Creates a Fighter instance from a dictionary (e.g., from DynamoDB)."""
    if not data:
        return None

    fighter = Fighter(name_enum) # Use the name_enum for correct FighterName
    fighter.hp = data.get("hp", MAX_HP)
    fighter.max_hp = data.get("max_hp", MAX_HP) # Should ideally be same as MAX_HP
    fighter.stamina = data.get("stamina", MAX_STAMINA)
    fighter.max_stamina = data.get("max_stamina", MAX_STAMINA) # Should be MAX_STAMINA
    fighter.knockdowns_this_round = data.get("knockdowns_this_round", 0)
    fighter.total_knockdowns = data.get("total_knockdowns", 0)

    current_action_str = data.get("current_action", "IDLE")
    try:
        fighter.current_action = ActionType[current_action_str]
    except KeyError:
        fighter.current_action = ActionType.IDLE # Default if invalid string

    fighter.action_start_time = data.get("action_start_time", 0) # May not be in older saves

    # Stats deserialization: ensure enum keys are handled if they were stored as strings
    raw_stats = data.get("stats", {})
    fighter.stats = create_empty_fighter_stats() # Start with a clean slate
    for k, v in raw_stats.items():
        try:
            action_key = ActionType[k] # If key is an ActionType string
            fighter.stats[action_key] = v
        except KeyError:
            fighter.stats[k] = v # For non-ActionType keys like "punches_thrown"

    fighter.round_scores = data.get("round_scores", [])
    return fighter

def create_gamestate_from_dict(data: dict) -> GameState:
    """Creates a GameState instance from a dictionary (e.g., from DynamoDB)."""
    if not data:
        return None

    game_state = GameState() # Creates player/opponent with defaults

    game_state.game_id = data.get("game_id") # Assuming game_id is stored at top level

    try:
        game_state.match_status = GameStatus[data.get("match_status", "PENDING")]
    except KeyError:
        game_state.match_status = GameStatus.PENDING

    game_state.current_round = data.get("current_round", 0)
    game_state.max_rounds = data.get("max_rounds", MAX_ROUNDS) # Should be MAX_ROUNDS
    game_state.round_timer = data.get("round_timer", ROUND_DURATION_SECONDS)
    game_state.is_round_active = data.get("is_round_active", False)
    game_state.between_rounds_timer = data.get("between_rounds_timer", 0)

    winner_val = data.get("winner")
    if winner_val:
        if winner_val == "draw":
            game_state.winner = "draw"
        else:
            try:
                game_state.winner = FighterName[winner_val]
            except KeyError:
                game_state.winner = None # Or log an error
    else:
        game_state.winner = None

    # Deserialize player and opponent
    player_data = data.get("player")
    if player_data:
        game_state.player = create_fighter_from_dict(player_data, FighterName.PLAYER)

    opponent_data = data.get("opponent")
    if opponent_data:
        game_state.opponent = create_fighter_from_dict(opponent_data, FighterName.OPPONENT)

    # Deserialize knockdown_info
    kd_info_data = data.get("knockdown_info", {})
    game_state.knockdown_info["is_knockdown"] = kd_info_data.get("is_knockdown", False)
    kd_fighter_str = kd_info_data.get("fighter_down")
    if kd_fighter_str:
        try:
            game_state.knockdown_info["fighter_down"] = FighterName[kd_fighter_str]
        except KeyError:
            game_state.knockdown_info["fighter_down"] = None
    else:
        game_state.knockdown_info["fighter_down"] = None
    game_state.knockdown_info["count"] = kd_info_data.get("count", 0)

    game_state.event_log = data.get("event_log", []) # Assumes event log is stored as list of strings
    game_state.last_tick_time = data.get("last_tick_time", time.time()) # Default to now if not present

    return game_state


# --- Placeholder Functions for API Interaction ---

def handle_start_game_request():
    """
    Placeholder for what might be called when a web server receives a 'start game' request.
    Returns the initial game state.
    """
    game = initialize_new_game()
    # In a real API, this would likely be stored in a session or database
    # and an ID returned to the client.
    # For now, we just return the object.
    print("[API Placeholder] handle_start_game_request called.")
    return game # Or a serializable version of game_state

def handle_player_action_request(current_game_state: GameState, player_action_data: dict):
    """
    Placeholder for processing a player's action received from the web front-end.
    `player_action_data` might be a dict like {"action": "JAB"}
    Updates `current_game_state` and potentially returns it or a status.
    """
    action_str = player_action_data.get("action")
    try:
        action = ActionType[action_str.upper()] # Convert string to ActionType enum
        print(f"[API Placeholder] Received player action: {action.value}")
        # In a real game, this action would be queued or processed by the game loop.
        # For direct testing, we can queue it for our test game_tick.
        if current_game_state.match_status == GameStatus.ACTIVE and current_game_state.is_round_active:
            queue_player_action_for_tick(action) # Uses the global test queue
            # execute_fighter_action(current_game_state, FighterName.PLAYER, action) # Alternative direct execution
            return {"status": "success", "message": f"Action {action.value} received and queued."}
        else:
            return {"status": "error", "message": "Game not active or round not active."}
    except KeyError:
        print(f"[API Placeholder] Invalid action string received: {action_str}")
        return {"status": "error", "message": f"Invalid action: {action_str}"}
    except Exception as e:
        print(f"[API Placeholder] Error processing action: {e}")
        return {"status": "error", "message": f"Error processing action: {str(e)}"}


def handle_get_game_state_request(current_game_state: GameState):
    """
    Placeholder for when the front-end requests the current game state.
    Returns a serializable version of the game state.
    """
    print("[API Placeholder] handle_get_game_state_request called.")
    # This would need to serialize the GameState object to JSON,
    # including nested Fighter objects and their stats.
    # For now, just returning the object directly.
    return current_game_state # Or a serialized_game_state


if __name__ == '__main__':
    # ... (previous test code remains) ...

    print("\n--- Testing API Placeholder Functions ---")
    # 1. Test starting a game
    game_instance_api = handle_start_game_request()
    assert game_instance_api.match_status == GameStatus.PENDING # Initial state before round starts
    print(f"Initial API game state HP: P:{game_instance_api.player.hp} O:{game_instance_api.opponent.hp}")

    # Manually start the first round for this test instance
    start_new_round(game_instance_api)
    print(f"Game state after starting round: {game_instance_api.match_status}")


    # 2. Test sending a player action
    action_data = {"action": "JAB"}
    response = handle_player_action_request(game_instance_api, action_data)
    print(f"API response to JAB action: {response}")
    assert response["status"] == "success"
    assert PLAYER_ACTION_QUEUE[-1] == ActionType.JAB # Check if it was added to our test queue

    # Simulate a game tick to process the queued action for this separate game_instance_api
    if PLAYER_ACTION_QUEUE: # Ensure the queue specific to this test path is processed
        game_instance_api.last_tick_time = time.time() # Initialize tick time for this instance
        game_tick(game_instance_api)
        print(f"API game state after JAB and tick: P HP: {game_instance_api.player.hp}, O HP: {game_instance_api.opponent.hp}")
        assert game_instance_api.opponent.hp < MAX_HP or not ACTION_DETAILS[ActionType.JAB]["accuracy"] # Opponent took damage or jab missed

    PLAYER_ACTION_QUEUE.clear() # Clear queue for next test

    action_data_invalid = {"action": "FLY"}
    response_invalid = handle_player_action_request(game_instance_api, action_data_invalid)
    print(f"API response to FLY action: {response_invalid}")
    assert response_invalid["status"] == "error"

    # 3. Test getting game state
    retrieved_state = handle_get_game_state_request(game_instance_api)
    assert retrieved_state.current_round == 1
    print(f"Retrieved game state round: {retrieved_state.current_round}, Player HP: {retrieved_state.player.hp}")


# Next steps: Implement Round/Match progression, AI, and game loop (game_tick)
# The agent will then call plan_step_complete.
